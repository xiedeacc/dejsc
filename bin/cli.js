#!/usr/bin/env node

const dejsc = require('../index');
const path = require('path');
const fs = require('fs');
const bytenode = require('bytenode')

const program = require('commander');

program
    .version(`dejsc v0.0.1 with nodejs ${process.version}`,
        '-v, --version', 'output the current version')
    .description("A tool to decompile V8 bytecodes generated by bytenode.")
    .option('-r, --run', 'run bytecode file, and show results on console.')
    .option('-x, --export', 'show module exports of bytecode file to console.')
    .option('-f, --fix', 'fix hash nnumber of bytecode.')
    .option('--compile', "compile javascript source code into bytecodes.")
    .option('--data-header', "show data header of bytecodes.")
    .arguments('<file> [othrFiles...]')
    .action(function(file, othrFiles) {
        // Check file
        filename = path.resolve(file);
        if (!(fs.existsSync(filename) && fs.statSync(filename).isFile())) {
            console.error(`Error: Cannot find file '${filename}'.`);
        }
        if (program.run) {
            let result = dejsc.runBytecodeFile(filename)
            console.log(result);
        } 
        else if (program.export) {
            let fakeModule = {};
            fakeModule.exports = {};
            (dejsc.runBytecodeFile(filename))(fakeModule.exports, require, fakeModule, __filename, __dirname)
            console.log(fakeModule.exports);
        }
        else if (program.compile) {
            let javascriptCode = fs.readFileSync(filename, 'utf-8');
            let bytecodeBuffer = bytenode.compileCode(javascriptCode);
            process.stdout.write(bytecodeBuffer);
        }
        else if (program.dataHeader) {
            let header = dejsc.readDataHeader(dejsc.readBytecodeFile(filename));
            console.log(header);
        }
    })

program.parse(process.argv);