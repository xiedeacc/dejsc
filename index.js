'use strict';

const fs = require('fs');
const vm = require('vm');
const v8 = require('v8');

/**
 * Runs v8 bytecode buffer and returns the result.
 * @param   {Buffer} bytecodeBuffer The buffer object that was created using compileCode function.
 * @returns {any}    The result of the very last statement executed in the script.
 */
const runBytecode = function (bytecodeBuffer, fakeScript = "") {

    if (!Buffer.isBuffer(bytecodeBuffer)) {
        throw new Error(`bytecodeBuffer must be a buffer object.`);
    }

    //fixBytecode(bytecodeBuffer);

    let length = readSourceHash(bytecodeBuffer);

    let dummyCode = "";
  
    if (length > 1) {
        dummyCode = '"' + "\u200b".repeat(length - 2) + '"'; // "\u200b" Zero width space
    }

    let script = new vm.Script(dummyCode, {
        cachedData: bytecodeBuffer
    });

    if (script.cachedDataRejected) {
        throw new Error('Invalid or incompatible cached data (cachedDataRejected)');
    }

    return script.runInThisContext();
};

/**
 * Runs .jsc file and returns the result.
 * @param   {string} filename
 * @returns {any}    The result of the very last statement executed in the script.
 */
const runBytecodeFile = function (filename) {  
    let bytecodeBuffer = readBytecodeFile(filename);
    return runBytecode(bytecodeBuffer, "");
};

const readBytecodeFile = function (filename) {
    if (typeof filename !== 'string') {
        throw new Error(`filename must be a string. ${typeof filename} was given.`);
    }
  
    return fs.readFileSync(filename);
}

const readSourceHash = function (bytecodeBuffer) {

    if (!Buffer.isBuffer(bytecodeBuffer)) {
        throw new Error(`bytecodeBuffer must be a buffer object.`);
    }
  
    if (process.version.startsWith('v8.8') || process.version.startsWith('v8.9')) {
        // Node is v8.8.x or v8.9.x
        return bytecodeBuffer.slice(12, 16).reduce((sum, number, power) => sum += number * Math.pow(256, power), 0);
    } else {
        return bytecodeBuffer.slice(8, 12).reduce((sum, number, power) => sum += number * Math.pow(256, power), 0);
    }
};

const readDataHeader = function(bytecodeBuffer) {
    if (!Buffer.isBuffer(bytecodeBuffer)) {
        throw new Error(`bytecodeBuffer must be a buffer object.`);
    }

    return {
        "magic_number"  : bytecodeBuffer.slice(0, 4),
        "version_hash"  : bytecodeBuffer.slice(4, 8),
        "source_hash"   : bytecodeBuffer.slice(8, 12),
        "cpu_features"  : bytecodeBuffer.slice(12, 16),
        "flag_hash"     : bytecodeBuffer.slice(16, 20)
    }
}

/**
 * Fix bytecode with current v8 data header field.
 * @param {*} bytecodeBuffer 
 */
const fixBytecode = function (bytecodeBuffer) {

    if (!Buffer.isBuffer(bytecodeBuffer)) {
        throw new Error(`bytecodeBuffer must be a buffer object.`);
    }

    let dummyBytecode = compileCode('"Hello World"');

    // Replace with current v8 version hash
    // [1] version hash
    dummyBytecode.slice(4, 8).copy(bytecodeBuffer, 4);
  
    // Replace with current cpu features and flag hash
    if (process.version.startsWith('v8.8') || process.version.startsWith('v8.9')) {
        dummyBytecode.slice(16, 20).copy(bytecodeBuffer, 16);
        dummyBytecode.slice(20, 24).copy(bytecodeBuffer, 20);
    } else if (process.version.startsWith('v12') || process.version.startsWith('v13')) {
        // cpu features entry has been removed
        // [3] flag hash
        dummyBytecode.slice(12, 16).copy(bytecodeBuffer, 12);
    } else {
        // [3] cpu features
        // [4] flag hash
        dummyBytecode.slice(12, 16).copy(bytecodeBuffer, 12);
        dummyBytecode.slice(16, 20).copy(bytecodeBuffer, 16);
    }
};

/**
 * Generates v8 bytecode buffer.
 * @param   {string} javascriptCode JavaScript source that will be compiled to bytecode.
 * @returns {Buffer} The generated bytecode.
 */
const compileCode = function (javascriptCode) {

    if (typeof javascriptCode !== 'string') {
        throw new Error(`javascriptCode must be string. ${typeof javascriptCode} was given.`);
    }
  
    let script = new vm.Script(javascriptCode, {
        produceCachedData: true
    });
  
    let bytecodeBuffer = (script.createCachedData && script.createCachedData.call) ?
        script.createCachedData()
        :
        script.cachedData;
    
    return bytecodeBuffer;
};

global.bytenode = {
    readBytecodeFile,
    runBytecode,
    runBytecodeFile,
    readDataHeader,
    fixBytecode
};
  
module.exports = global.bytenode;